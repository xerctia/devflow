{
  "version": 3,
  "sources": ["../../../../src/cli/codegen_templates/component_api.ts"],
  "sourcesContent": ["import path from \"path\";\nimport { z } from \"zod\";\nimport { Context } from \"../../bundler/context.js\";\nimport { entryPoints } from \"../../bundler/index.js\";\nimport {\n  ComponentDirectory,\n  toComponentDefinitionPath,\n} from \"../lib/components/definition/directoryStructure.js\";\nimport { StartPushResponse } from \"../lib/deployApi/startPush.js\";\nimport { importPath, moduleIdentifier } from \"./api.js\";\nimport { header } from \"./common.js\";\nimport {\n  ComponentExports,\n  EvaluatedComponentDefinition,\n} from \"../lib/deployApi/componentDefinition.js\";\nimport { ComponentDefinitionPath } from \"../lib/deployApi/paths.js\";\nimport { Identifier, Reference } from \"../lib/deployApi/types.js\";\nimport {\n  ConvexValidator,\n  convexValidator,\n} from \"../lib/deployApi/validator.js\";\nimport { CanonicalizedModulePath } from \"../lib/deployApi/paths.js\";\nimport { Value, jsonToConvex } from \"../../values/value.js\";\n\nexport function componentApiJs() {\n  const lines = [];\n  lines.push(header(\"Generated `api` utility.\"));\n  lines.push(`\n    import { anyApi, componentsGeneric } from \"convex/server\";\n\n    /**\n     * A utility for referencing Convex functions in your app's API.\n     *\n     * Usage:\n     * \\`\\`\\`js\n     * const myFunctionReference = api.myModule.myFunction;\n     * \\`\\`\\`\n     */\n    export const api = anyApi;\n    export const internal = anyApi;\n    export const components = componentsGeneric();\n  `);\n  return lines.join(\"\\n\");\n}\n\nexport function rootComponentApiCJS() {\n  const lines = [];\n  lines.push(header(\"Generated `api` utility.\"));\n  lines.push(`const { anyApi } = require(\"convex/server\");`);\n  lines.push(`module.exports = {\n    api: anyApi,\n    internal: anyApi,\n  };`);\n  return lines.join(\"\\n\");\n}\n\nexport function componentApiStubDTS() {\n  const lines = [];\n  lines.push(header(\"Generated `api` utility.\"));\n  lines.push(`import type { AnyApi, AnyComponents } from \"convex/server\";`);\n  lines.push(`\n    export declare const api: AnyApi;\n    export declare const internal: AnyApi;\n    export declare const components: AnyComponents;\n  `);\n\n  return lines.join(\"\\n\");\n}\n\nexport async function componentApiDTS(\n  ctx: Context,\n  startPush: StartPushResponse,\n  rootComponent: ComponentDirectory,\n  componentDirectory: ComponentDirectory,\n) {\n  const definitionPath = toComponentDefinitionPath(\n    rootComponent,\n    componentDirectory,\n  );\n  const absModulePaths = await entryPoints(ctx, componentDirectory.path);\n  const modulePaths = absModulePaths.map((p) =>\n    path.relative(componentDirectory.path, p),\n  );\n\n  const lines = [];\n  lines.push(header(\"Generated `api` utility.\"));\n  for (const modulePath of modulePaths) {\n    const ident = moduleIdentifier(modulePath);\n    const path = importPath(modulePath);\n    lines.push(`import type * as ${ident} from \"../${path}.js\";`);\n  }\n  lines.push(`\n    import type {\n      ApiFromModules,\n      FilterApi,\n      FunctionReference,\n    } from \"convex/server\";\n    /**\n     * A utility for referencing Convex functions in your app's API.\n     *\n     * Usage:\n     * \\`\\`\\`js\n     * const myFunctionReference = api.myModule.myFunction;\n     * \\`\\`\\`\n     */\n    declare const fullApi: ApiFromModules<{\n  `);\n  for (const modulePath of modulePaths) {\n    const ident = moduleIdentifier(modulePath);\n    const path = importPath(modulePath);\n    lines.push(`  \"${path}\": typeof ${ident},`);\n  }\n  lines.push(`}>;`);\n  for await (const line of codegenApiWithMounts(\n    ctx,\n    startPush,\n    definitionPath,\n  )) {\n    lines.push(line);\n  }\n  lines.push(`\n    export declare const api: FilterApi<typeof fullApiWithMounts, FunctionReference<any, \"public\">>;\n    export declare const internal: FilterApi<typeof fullApiWithMounts, FunctionReference<any, \"internal\">>;\n  `);\n\n  lines.push(`\n  export declare const components: {`);\n\n  const analysis = startPush.analysis[definitionPath];\n  if (!analysis) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `No analysis found for component ${definitionPath} orig: ${definitionPath}\\nin\\n${Object.keys(startPush.analysis).toString()}`,\n    });\n  }\n  for (const childComponent of analysis.definition.childComponents) {\n    const childComponentAnalysis = startPush.analysis[childComponent.path];\n    if (!childComponentAnalysis) {\n      return await ctx.crash({\n        exitCode: 1,\n        errorType: \"fatal\",\n        printedMessage: `No analysis found for child component ${childComponent.path}`,\n      });\n    }\n    for await (const line of codegenExports(\n      ctx,\n      childComponent.name,\n      childComponentAnalysis,\n    )) {\n      lines.push(line);\n    }\n  }\n\n  lines.push(\"};\");\n\n  return lines.join(\"\\n\");\n}\n\nasync function* codegenApiWithMounts(\n  ctx: Context,\n  startPush: StartPushResponse,\n  definitionPath: ComponentDefinitionPath,\n): AsyncGenerator<string> {\n  const mountTree = await buildMountTree(ctx, startPush, definitionPath, []);\n  if (mountTree) {\n    yield \"export type Mounts = \";\n    yield* codegenMountTree(mountTree);\n    yield `;`;\n    yield `// For now fullApiWithMounts is only fullApi which provides`;\n    yield `// jump-to-definition in component client code.`;\n    yield `// Use Mounts for the same type without the inference.`;\n    yield \"declare const fullApiWithMounts: typeof fullApi;\";\n  } else {\n    yield \"declare const fullApiWithMounts: typeof fullApi;\";\n  }\n}\n\nfunction* codegenMountTree(tree: MountTree): Generator<string> {\n  yield `{`;\n  for (const [identifier, subtree] of Object.entries(tree)) {\n    if (typeof subtree === \"string\") {\n      yield `\"${identifier}\": ${subtree},`;\n    } else {\n      yield `\"${identifier}\":`;\n      yield* codegenMountTree(subtree);\n      yield `,`;\n    }\n  }\n  yield `}`;\n}\n\ninterface MountTree {\n  [identifier: string]: MountTree | string;\n}\n\nasync function buildMountTree(\n  ctx: Context,\n  startPush: StartPushResponse,\n  definitionPath: ComponentDefinitionPath,\n  attributes: string[],\n): Promise<MountTree | null> {\n  // TODO make these types more precise when receiving analysis from server\n  const analysis = startPush.analysis[definitionPath];\n  if (!analysis) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `No analysis found for component ${definitionPath} orig: ${definitionPath}\\nin\\n${Object.keys(startPush.analysis).toString()}`,\n    });\n  }\n  let current = analysis.definition.exports.branch;\n  for (const attribute of attributes) {\n    const componentExport = current.find(\n      ([identifier]) => identifier === attribute,\n    );\n    if (!componentExport) {\n      return await ctx.crash({\n        exitCode: 1,\n        errorType: \"fatal\",\n        printedMessage: `No export found for ${attribute}`,\n      });\n    }\n    const [_, node] = componentExport;\n    if (node.type !== \"branch\") {\n      return await ctx.crash({\n        exitCode: 1,\n        errorType: \"fatal\",\n        printedMessage: `Expected branch at ${attribute}`,\n      });\n    }\n    current = node.branch;\n  }\n  return buildComponentMountTree(ctx, startPush, analysis, current);\n}\n\nasync function buildComponentMountTree(\n  ctx: Context,\n  startPush: StartPushResponse,\n  analysis: EvaluatedComponentDefinition,\n  exports: Array<[Identifier, ComponentExports]>,\n): Promise<MountTree | null> {\n  const result: MountTree = {};\n  let nonEmpty = false;\n  for (const [identifier, componentExport] of exports) {\n    if (componentExport.type === \"leaf\") {\n      // If we're at a child component reference, follow it and build its export tree.\n      if (componentExport.leaf.startsWith(\"_reference/childComponent/\")) {\n        const suffix = componentExport.leaf.slice(\n          \"_reference/childComponent/\".length,\n        );\n        const [componentName, ...attributes] = suffix.split(\"/\");\n        const childComponent = analysis.definition.childComponents.find(\n          (c) => c.name === componentName,\n        );\n        if (!childComponent) {\n          return await ctx.crash({\n            exitCode: 1,\n            errorType: \"fatal\",\n            printedMessage: `No child component found for ${componentName}`,\n          });\n        }\n        const childTree = await buildMountTree(\n          ctx,\n          startPush,\n          childComponent.path,\n          attributes,\n        );\n        if (childTree) {\n          result[identifier] = childTree;\n          nonEmpty = true;\n        }\n      }\n      // If we're at a function reference outside the root, codegen it as a leaf.\n      const isRoot = analysis.definition.definitionType.type === \"app\";\n      if (!isRoot && componentExport.leaf.startsWith(\"_reference/function/\")) {\n        const leaf = await resolveFunctionReference(\n          ctx,\n          analysis,\n          componentExport.leaf,\n          \"public\",\n        );\n        result[identifier] = leaf;\n        nonEmpty = true;\n      }\n    } else {\n      const subTree = await buildComponentMountTree(\n        ctx,\n        startPush,\n        analysis,\n        componentExport.branch,\n      );\n      if (subTree) {\n        result[identifier] = subTree;\n        nonEmpty = true;\n      }\n    }\n  }\n  return nonEmpty ? result : null;\n}\n\nasync function* codegenExports(\n  ctx: Context,\n  name: Identifier,\n  analysis: EvaluatedComponentDefinition,\n): AsyncGenerator<string> {\n  yield `${name}: {`;\n  for (const [name, componentExport] of analysis.definition.exports.branch) {\n    yield `${name}:`;\n    yield* codegenExport(ctx, analysis, componentExport);\n    yield \",\";\n  }\n  yield \"},\";\n}\n\nasync function* codegenExport(\n  ctx: Context,\n  analysis: EvaluatedComponentDefinition,\n  componentExport: ComponentExports,\n): AsyncGenerator<string> {\n  if (componentExport.type === \"leaf\") {\n    yield await resolveFunctionReference(\n      ctx,\n      analysis,\n      componentExport.leaf,\n      \"internal\",\n    );\n  } else if (componentExport.type === \"branch\") {\n    yield \"{\";\n    for (const [name, childExport] of componentExport.branch) {\n      yield `${name}:`;\n      yield* codegenExport(ctx, analysis, childExport);\n      yield \",\";\n    }\n    yield \"}\";\n  }\n}\n\nexport async function resolveFunctionReference(\n  ctx: Context,\n  analysis: EvaluatedComponentDefinition,\n  reference: Reference,\n  visibility: \"public\" | \"internal\",\n) {\n  if (!reference.startsWith(\"_reference/function/\")) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Invalid function reference: ${reference}`,\n    });\n  }\n  const udfPath = reference.slice(\"_reference/function/\".length);\n\n  const [modulePath, functionName] = udfPath.split(\":\");\n  const canonicalizedModulePath = canonicalizeModulePath(modulePath);\n\n  const analyzedModule = analysis.functions[canonicalizedModulePath];\n  if (!analyzedModule) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Module not found: ${modulePath}`,\n    });\n  }\n  const analyzedFunction = analyzedModule.functions.find(\n    (f) => f.name === functionName,\n  );\n  if (!analyzedFunction) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Function not found: ${functionName}`,\n    });\n  }\n\n  // The server sends down `udfType` capitalized.\n  const udfType = analyzedFunction.udfType.toLowerCase();\n\n  let argsType = \"any\";\n  try {\n    const argsValidator = parseValidator(analyzedFunction.args);\n    if (argsValidator) {\n      if (argsValidator.type === \"object\" || argsValidator.type === \"any\") {\n        argsType = validatorToType(argsValidator);\n      } else {\n        // eslint-disable-next-line no-restricted-syntax\n        throw new Error(\n          `Unexpected argument validator type: ${argsValidator.type}`,\n        );\n      }\n    }\n  } catch (e) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Invalid function args: ${analyzedFunction.args}`,\n      errForSentry: e,\n    });\n  }\n\n  let returnsType = \"any\";\n  try {\n    const returnsValidator = parseValidator(analyzedFunction.returns);\n    if (returnsValidator) {\n      returnsType = validatorToType(returnsValidator);\n    }\n  } catch (e) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Invalid function returns: ${analyzedFunction.returns}`,\n      errForSentry: e,\n    });\n  }\n\n  return `FunctionReference<\"${udfType}\", \"${visibility}\", ${argsType}, ${returnsType}>`;\n}\n\nfunction parseValidator(validator: string | null): ConvexValidator | null {\n  if (!validator) {\n    return null;\n  }\n  return z.nullable(convexValidator).parse(JSON.parse(validator));\n}\n\nfunction canonicalizeModulePath(modulePath: string): CanonicalizedModulePath {\n  if (!modulePath.endsWith(\".js\")) {\n    return modulePath + \".js\";\n  }\n  return modulePath;\n}\n\nfunction validatorToType(validator: ConvexValidator): string {\n  if (validator.type === \"null\") {\n    return \"null\";\n  } else if (validator.type === \"number\") {\n    return \"number\";\n  } else if (validator.type === \"bigint\") {\n    return \"bigint\";\n  } else if (validator.type === \"boolean\") {\n    return \"boolean\";\n  } else if (validator.type === \"string\") {\n    return \"string\";\n  } else if (validator.type === \"bytes\") {\n    return \"ArrayBuffer\";\n  } else if (validator.type === \"any\") {\n    return \"any\";\n  } else if (validator.type === \"literal\") {\n    const convexValue = jsonToConvex(validator.value);\n    return convexValueToLiteral(convexValue);\n  } else if (validator.type === \"id\") {\n    return \"string\";\n  } else if (validator.type === \"array\") {\n    return `Array<${validatorToType(validator.value)}>`;\n  } else if (validator.type === \"record\") {\n    return `Record<${validatorToType(validator.keys)}, ${validatorToType(validator.values.fieldType)}>`;\n  } else if (validator.type === \"union\") {\n    return validator.value.map(validatorToType).join(\" | \");\n  } else if (validator.type === \"object\") {\n    return objectValidatorToType(validator.value);\n  } else {\n    // eslint-disable-next-line no-restricted-syntax\n    throw new Error(`Unsupported validator type`);\n  }\n}\n\nfunction objectValidatorToType(\n  fields: Record<string, { fieldType: ConvexValidator; optional: boolean }>,\n): string {\n  const fieldStrings: string[] = [];\n  for (const [fieldName, field] of Object.entries(fields)) {\n    const fieldType = validatorToType(field.fieldType);\n    fieldStrings.push(`${fieldName}${field.optional ? \"?\" : \"\"}: ${fieldType}`);\n  }\n  return `{ ${fieldStrings.join(\", \")} }`;\n}\n\nfunction convexValueToLiteral(value: Value): string {\n  if (value === null) {\n    return \"null\";\n  }\n  if (typeof value === \"bigint\") {\n    return `${value}n`;\n  }\n  if (typeof value === \"number\") {\n    return `${value}`;\n  }\n  if (typeof value === \"boolean\") {\n    return `${value}`;\n  }\n  if (typeof value === \"string\") {\n    return `\"${value}\"`;\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  throw new Error(`Unsupported literal type`);\n}\n"],
  "mappings": "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",
  "names": ["path", "name"]
}
